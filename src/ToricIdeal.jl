using Oscar
using Bijections

import Base: Vector
import Oscar: toric_ideal, Graph, Undirected, Directed
# import Graphs: vertices, Edge

@doc raw"""
    edge_ring((G::Graph{Directed})

Returns for a given graph `G` the polynomial ring in variables $e_ij$ for every edge $i\to j$.

# Examples
```jldoctest
julia> complete_dag(3) |> edge_ring
Multivariate polynomial ring in 3 variables e12, e13, e23
  over rational field

julia> complete_dag(4) |> edge_ring
Multivariate polynomial ring in 6 variables e12, e13, e23, e14, ..., e34
  over rational field
```
"""
function edge_ring(G::Graph{Directed})
    #TODO: Change to return also vars
    return first(polynomial_ring(QQ, variable_labels(G)))
end

function edge_ring_inclusion(G::Graph{Directed}, H::Graph{Directed})
    R, P = edge_ring.([G,H])

    im = gens(R)[edges_by_target(H) .|>  (e->findfirst(x->e==x, edges_by_target(G)))]

    return hom(P, R, im)
end

function tropical_edge_ring(G::Graph{Directed}; minmax=min)
    #TODO: Change to return also vars
    return first(polynomial_ring(tropical_semiring(minmax), variable_labels(G)))
end

function edges_for_variables(G::Graph{Directed})
    return Dict(zip(gens(edge_ring(G)), edges_by_target(G)))
end

@doc raw"""
    design_matrix((G::Graph{Directed})

Returns for a given graph `G` the design matrix, that is, the constraint matrix 
associated to the all-pairs shortest-paths problem on $G$.

# Examples
```jldoctest
julia> complete_dag(3) |> design_matrix
[ 1    1    0]
[-1    0    1]
[ 0   -1   -1]

julia> complete_dag(4) |> design_matrix
[ 1    1    1    0    0    0]
[-1    0    0    1    1    0]
[ 0   -1    0   -1    0    1]
[ 0    0   -1    0   -1   -1]
```
"""
function design_matrix(G::Graph{Directed})
    #TODO: I think this is called a presentation matrix (cf. semigroup presentations)
    I = indices(G)
    A = zero_matrix(ZZ, nv(G), length(I))

    for j in 1:nv(G)
        for i in inneighbors(G,j)
            A[j, get(I, Edge(i,j), 0)] = -1
        end
        for i in outneighbors(G,j)
            A[j, get(I, Edge(j,i), 0)] = 1
        end
    end

    return A
end

@doc raw"""
    toric_ideal((G::Graph{Directed})

Returns for a given graph `G` the toric ideal of the design matrix in the edge ring.

# Examples
```jldoctest
julia> complete_dag(3) |> toric_ideal
Ideal generated by
  -e12*e23 + e13

julia> complete_dag(4) |> toric_ideal
Ideal generated by
  e12*e24 - e14
  e12*e23 - e13
  e13*e34 - e14
  e23*e34 - e24
```
"""
function toric_ideal(G::Graph{Directed})
    R = edge_ring(G)
    MB = design_matrix(G) |> markov_basis

    return binomial_exponents_to_ideal(R, MB)
end

# function parse_gfan_output(s::String)
#     unnecessary_stuff = ['{', '}', '\n', ',', ' ']

#     cleaned_bases = s |>
#         (x -> split(x, "{{")[2]) |> 
#         (x -> strip(x, unnecessary_stuff)) |> 
#         (x -> split(x, "}\n")) .|>
#         (x -> strip(x, unnecessary_stuff)) .|>
#         (x -> split(x, ","))
        
#     output = map(x -> map(y -> strip(y), x), cleaned_bases)
#     initial_terms = map(y -> map(x -> split(x, ['+', '-'])|>first, y), output)

#     return output, initial_terms
# end

# function construct_poly(B::Vector{String})
#     return map(f -> eval(Meta.parse(f)), B)
# end

# function construct_poly(B::Vector{SubString{String}})
#     return construct_poly(String.(B))
# end

# function gfan(I::Ideal)
#     basis = gens(I)
#     vars = gens(base_ring(I))

#     input = "Q[" * join(vars, ",") * "]{" * join(basis, ",") * "}"

#     # println(input)

#     output = read(pipeline(`gfan_bases`, stdin=IOBuffer(input)), String)
#     parsed, parsed_initials = parse_gfan_output(output)
#     # bases = construct_poly.(parsed)
#     # initials = construct_poly.(parsed_initials)

#     return parsed, parsed_initials
#     # return bases, initials
# end