using Oscar
using Bijections

import Base: Vector
import Oscar: toric_ideal, Graph, Undirected, Directed
# import Graphs: vertices, Edge

@doc raw"""
    edge_ring((G::Graph{Directed})

Returns for a given graph `G` the polynomial ring in variables $e_ij$ for every edge $i\to j$.

# Examples
```jldoctest
julia> complete_dag(3) |> edge_ring
Multivariate polynomial ring in 3 variables e12, e13, e23
  over rational field

julia> complete_dag(4) |> edge_ring
Multivariate polynomial ring in 6 variables e12, e13, e23, e14, ..., e34
  over rational field
```
"""
function edge_ring(G::Graph{Directed})
    return polynomial_ring(QQ, variable_labels(G))
end

function edge_ring_inclusion(G::Graph{Directed}, H::Graph{Directed})
    R, P = edge_ring.([G,H])

    im = gens(R)[edges_by_target(H) .|>  (e->findfirst(x->e==x, edges_by_target(G)))]

    return hom(P, R, im)
end

function tropical_edge_ring(G::Graph{Directed}; minmax=min)
    #TODO: Change to return also vars
    return first(polynomial_ring(tropical_semiring(minmax), variable_labels(G)))
end

function edges_for_variables(G::Graph{Directed})
    return Dict(zip(gens(edge_ring(G)), edges_by_target(G)))
end

@doc raw"""
    design_matrix((G::Graph{Directed})

Returns for a given graph `G` the design matrix for the all-pairs shortest-paths problem on $G$.

# Examples
```jldoctest
julia> complete_dag(3) |> design_matrix
[ 1    1    0]
[-1    0    1]
[ 0   -1   -1]

julia> complete_dag(4) |> design_matrix
[ 1    1    1    0    0    0]
[-1    0    0    1    1    0]
[ 0   -1    0   -1    0    1]
[ 0    0   -1    0   -1   -1]
```
"""
function design_matrix(G::Graph{Directed})
    #TODO: I think this is called a presentation matrix (cf. semigroup presentations)
    I = indices(G)
    A = zero_matrix(ZZ, nv(G), length(I))

    for j in 1:nv(G)
        for i in inneighbors(G,j)
            A[j, get(I, Edge(i,j), 0)] = -1
        end
        for i in outneighbors(G,j)
            A[j, get(I, Edge(j,i), 0)] = 1
        end
    end

    return A
end

@doc raw"""
    toric_ideal((G::Graph{Directed})

Returns for a given graph `G` the toric ideal of the design matrix in the edge ring.

# Examples
```jldoctest
julia> complete_dag(3) |> toric_ideal
Ideal generated by
  -e12*e23 + e13

julia> complete_dag(4) |> toric_ideal
Ideal generated by
  e12*e24 - e14
  e12*e23 - e13
  e13*e34 - e14
  e23*e34 - e24
```
"""
function toric_ideal(G::Graph{Directed})
    R = edge_ring(G) |> first
    MB = design_matrix(G) |> markov_basis

    return binomial_exponents_to_ideal(R, MB)
end

@doc raw"""
    all_pairs_shortest_path_ideal(G::Graph{Directed})

Returns for a given directed graph `G` the toric ideal for the all-pairs shortest-paths problem.

# Examples
```jldoctest
julia> complete_dag(3) |> all_pairs_shortest_path_ideal
Ideal generated by
  e13 - e12*e23

julia> complete_dag(4) |> all_pairs_shortest_path_ideal
Ideal generated by
  e12*e23 - e13
  e12*e24 - e14
  e13*e34 - e14
  e23*e34 - e24
```
"""
function all_pairs_shortest_path_ideal(G::Graph{Directed})
  R,x = edge_ring(G)
  I = indices(G)

  F = map(edges(G)) do e
    i = src(e)
    j = dst(e)
    K = filter(1:n_vertices(G)) do k
      has_edge(G, src(e), k) && has_edge(G, k, dst(e))
    end

    map(K) do k
      x[I[Edge(i,k)]]*x[I[Edge(k,j)]] - x[I[Edge(i,j)]]
    end
  end |> splat(vcat)

  return ideal(F)
end
